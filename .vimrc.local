" With a map leader it's possible to do extra key combinations
"Turn line numbers on
let mapleader = "\<Space>"
let g:mapleader = "\<Space>"

" Open new file
nnoremap <Leader>o :CtrlP<CR>

" fuzzy find buffers
noremap <leader><leader> :CtrlPBuffer<cr>

" Save file
nnoremap <Leader>w :w<CR>

set clipboard=unnamed

set relativenumber 

" Don't show seperators for airline
let g:airline_left_sep=''
let g:airline_right_sep=''

" Automatically close tabs when opening files
autocmd BufRead * setlocal foldmethod=marker
autocmd BufRead * normal zM

" Don't show intro
set shortmess+=I

" Autofocus tagbar when expanded
let g:tagbar_autofocus = 1

" switch place of buffers
noremap <leader>bh <c-w>H
noremap <leader>bj <c-w>J
noremap <leader>bk <c-w>K
noremap <leader>bl <c-w>L

" Change colourscheme when diffing
fun! SetDiffColors()
  highlight DiffAdd    cterm=bold ctermfg=white ctermbg=DarkGreen
  highlight DiffDelete cterm=bold ctermfg=white ctermbg=DarkGrey
  highlight DiffChange cterm=bold ctermfg=white ctermbg=DarkBlue
  highlight DiffText   cterm=bold ctermfg=white ctermbg=DarkRed
endfun
autocmd FilterWritePre * call SetDiffColors()

" Better splits (new windows appear below and to the right)
set splitbelow
set splitright

" Faster search
let g:ctrlp_use_caching = 0
if executable('ag')
  set grepprg=ag\ --nogroup\ --nocolor

  let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
else
   let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files . -co --exclude-standard', 'find %s -type f']
   let g:ctrlp_prompt_mappings = {
      \ 'AcceptSelection("e")': ['<space>', '<cr>', '<2-LeftMouse>'],
       \ }
endif

" Gist authorisation settings
let g:github_user = $GITHUB_USER
let g:github_token = $GITHUB_TOKEN
let g:gist_detect_filetype = 1
let g:gist_open_browser_after_post = 1

" highlight a matching [{()}] when cursor is placed on start/end character
set showmatch

" Highlight the current line
set cursorline

" Autoload files that have changed outside of vim
set autoread

" This buffer is used the same as :! but the output is sent to a scratch buffer
" :Shell la -a
" Create a 'scratch buffer' which is a temporary buffer Vim wont ask to save
" http://vim.wikia.com/wiki/Display_output_of_shell_commands_in_new_window
command! -complete=shellcmd -nargs=+ Shell call s:RunShellCommand(<q-args>)
function! s:RunShellCommand(cmdline)
  echo a:cmdline
  let expanded_cmdline = a:cmdline
  for part in split(a:cmdline, ' ')
    if part[0] =~ '\v[%#<]'
      let expanded_part = fnameescape(expand(part))
      let expanded_cmdline = substitute(expanded_cmdline, part, expanded_part, '')
    endif
  endfor
  botright new
  setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile nowrap
  call setline(1, 'You entered:    ' . a:cmdline)
  call setline(2, 'Expanded Form:  ' .expanded_cmdline)
  call setline(3,substitute(getline(2),'.','=','g'))
  execute '$read !'. expanded_cmdline
  setlocal nomodifiable
  1
endfunction

" For solarized color scheme
syntax enable
set background=dark
colorscheme solarized
let g:solarized_termcolors=256

" Always highlight column 80 so it's easier to see where
" cutoff appears on longer screens
autocmd BufWinEnter * highlight ColorColumn ctermbg=gray
set colorcolumn=80
